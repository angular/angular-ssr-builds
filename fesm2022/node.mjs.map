{"version":3,"file":"node.mjs","sources":["../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/errors.ts","../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/common-engine/inline-css-processor.ts","../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/common-engine/peformance-profiler.ts","../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/common-engine/common-engine.ts","../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/request.ts","../../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/angular/ssr/node/src/response.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Attaches listeners to the Node.js process to capture and handle unhandled rejections and uncaught exceptions.\n * Captured errors are logged to the console. This function logs errors to the console, preventing unhandled errors\n * from crashing the server. It is particularly useful for Zoneless apps, ensuring error handling without relying on Zone.js.\n *\n * @remarks\n * This function is a no-op if zone.js is available.\n * For Zone-based apps, similar functionality is provided by Zone.js itself. See the Zone.js implementation here:\n * https://github.com/angular/angular/blob/4a8d0b79001ec09bcd6f2d6b15117aa6aac1932c/packages/zone.js/lib/node/node.ts#L94%7C\n *\n * @internal\n */\nexport function attachNodeGlobalErrorHandlers(): void {\n  if (typeof Zone !== 'undefined') {\n    return;\n  }\n\n  // Ensure that the listeners are registered only once.\n  // Otherwise, multiple instances may be registered during edit/refresh.\n  const gThis: typeof globalThis & { ngAttachNodeGlobalErrorHandlersCalled?: boolean } = globalThis;\n  if (gThis.ngAttachNodeGlobalErrorHandlersCalled) {\n    return;\n  }\n\n  gThis.ngAttachNodeGlobalErrorHandlersCalled = true;\n\n  process\n    // eslint-disable-next-line no-console\n    .on('unhandledRejection', (error) => console.error('unhandledRejection', error))\n    // eslint-disable-next-line no-console\n    .on('uncaughtException', (error) => console.error('uncaughtException', error));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport { ɵInlineCriticalCssProcessor as InlineCriticalCssProcessor } from '@angular/ssr';\nimport { readFile } from 'node:fs/promises';\n\nexport class CommonEngineInlineCriticalCssProcessor {\n  private readonly resourceCache = new Map<string, string>();\n\n  async process(html: string, outputPath: string | undefined): Promise<string> {\n    const beasties = new InlineCriticalCssProcessor(async (path) => {\n      let resourceContent = this.resourceCache.get(path);\n      if (resourceContent === undefined) {\n        resourceContent = await readFile(path, 'utf-8');\n        this.resourceCache.set(path, resourceContent);\n      }\n\n      return resourceContent;\n    }, outputPath);\n\n    return beasties.process(html);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst PERFORMANCE_MARK_PREFIX = '🅰️';\n\nexport function printPerformanceLogs(): void {\n  let maxWordLength = 0;\n  const benchmarks: [step: string, value: string][] = [];\n\n  for (const { name, duration } of performance.getEntriesByType('measure')) {\n    if (!name.startsWith(PERFORMANCE_MARK_PREFIX)) {\n      continue;\n    }\n\n    // `🅰️:Retrieve SSG Page` -> `Retrieve SSG Page:`\n    const step = name.slice(PERFORMANCE_MARK_PREFIX.length + 1) + ':';\n    if (step.length > maxWordLength) {\n      maxWordLength = step.length;\n    }\n\n    benchmarks.push([step, `${duration.toFixed(1)}ms`]);\n    performance.clearMeasures(name);\n  }\n\n  /* eslint-disable no-console */\n  console.log('********** Performance results **********');\n  for (const [step, value] of benchmarks) {\n    const spaces = maxWordLength - step.length + 5;\n    console.log(step + ' '.repeat(spaces) + value);\n  }\n  console.log('*****************************************');\n  /* eslint-enable no-console */\n}\n\nexport async function runMethodAndMeasurePerf<T>(\n  label: string,\n  asyncMethod: () => Promise<T>,\n): Promise<T> {\n  const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;\n  const startLabel = `start:${labelName}`;\n  const endLabel = `end:${labelName}`;\n\n  try {\n    performance.mark(startLabel);\n\n    return await asyncMethod();\n  } finally {\n    performance.mark(endLabel);\n    performance.measure(labelName, startLabel, endLabel);\n    performance.clearMarks(startLabel);\n    performance.clearMarks(endLabel);\n  }\n}\n\nexport function noopRunMethodAndMeasurePerf<T>(\n  label: string,\n  asyncMethod: () => Promise<T>,\n): Promise<T> {\n  return asyncMethod();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport { ApplicationRef, StaticProvider, Type } from '@angular/core';\nimport { BootstrapContext } from '@angular/platform-browser';\nimport { renderApplication, renderModule, ɵSERVER_CONTEXT } from '@angular/platform-server';\nimport * as fs from 'node:fs';\nimport { dirname, join, normalize, resolve } from 'node:path';\nimport { URL } from 'node:url';\nimport { attachNodeGlobalErrorHandlers } from '../errors';\nimport { CommonEngineInlineCriticalCssProcessor } from './inline-css-processor';\nimport {\n  noopRunMethodAndMeasurePerf,\n  printPerformanceLogs,\n  runMethodAndMeasurePerf,\n} from './peformance-profiler';\n\nconst SSG_MARKER_REGEXP = /ng-server-context=[\"']\\w*\\|?ssg\\|?\\w*[\"']/;\n\nexport interface CommonEngineOptions {\n  /** A method that when invoked returns a promise that returns an `ApplicationRef` instance once resolved or an NgModule. */\n  bootstrap?: Type<{}> | ((context: BootstrapContext) => Promise<ApplicationRef>);\n\n  /** A set of platform level providers for all requests. */\n  providers?: StaticProvider[];\n\n  /** Enable request performance profiling data collection and printing the results in the server console. */\n  enablePerformanceProfiler?: boolean;\n}\n\nexport interface CommonEngineRenderOptions {\n  /** A method that when invoked returns a promise that returns an `ApplicationRef` instance once resolved or an NgModule. */\n  bootstrap?: Type<{}> | ((context: BootstrapContext) => Promise<ApplicationRef>);\n\n  /** A set of platform level providers for the current request. */\n  providers?: StaticProvider[];\n  url?: string;\n  document?: string;\n  documentFilePath?: string;\n\n  /**\n   * Reduce render blocking requests by inlining critical CSS.\n   * Defaults to true.\n   */\n  inlineCriticalCss?: boolean;\n\n  /**\n   * Base path location of index file.\n   * Defaults to the 'documentFilePath' dirname when not provided.\n   */\n  publicPath?: string;\n}\n\n/**\n * A common engine to use to server render an application.\n */\n\nexport class CommonEngine {\n  private readonly templateCache = new Map<string, string>();\n  private readonly inlineCriticalCssProcessor = new CommonEngineInlineCriticalCssProcessor();\n  private readonly pageIsSSG = new Map<string, boolean>();\n\n  constructor(private options?: CommonEngineOptions) {\n    attachNodeGlobalErrorHandlers();\n  }\n\n  /**\n   * Render an HTML document for a specific URL with specified\n   * render options\n   */\n  async render(opts: CommonEngineRenderOptions): Promise<string> {\n    const enablePerformanceProfiler = this.options?.enablePerformanceProfiler;\n\n    const runMethod = enablePerformanceProfiler\n      ? runMethodAndMeasurePerf\n      : noopRunMethodAndMeasurePerf;\n\n    let html = await runMethod('Retrieve SSG Page', () => this.retrieveSSGPage(opts));\n\n    if (html === undefined) {\n      html = await runMethod('Render Page', () => this.renderApplication(opts));\n\n      if (opts.inlineCriticalCss !== false) {\n        const content = await runMethod('Inline Critical CSS', () =>\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.inlineCriticalCss(html!, opts),\n        );\n\n        html = content;\n      }\n    }\n\n    if (enablePerformanceProfiler) {\n      printPerformanceLogs();\n    }\n\n    return html;\n  }\n\n  private inlineCriticalCss(html: string, opts: CommonEngineRenderOptions): Promise<string> {\n    const outputPath =\n      opts.publicPath ?? (opts.documentFilePath ? dirname(opts.documentFilePath) : '');\n\n    return this.inlineCriticalCssProcessor.process(html, outputPath);\n  }\n\n  private async retrieveSSGPage(opts: CommonEngineRenderOptions): Promise<string | undefined> {\n    const { publicPath, documentFilePath, url } = opts;\n    if (!publicPath || !documentFilePath || url === undefined) {\n      return undefined;\n    }\n\n    const { pathname } = new URL(url, 'resolve://');\n    // Do not use `resolve` here as otherwise it can lead to path traversal vulnerability.\n    // See: https://portswigger.net/web-security/file-path-traversal\n    const pagePath = join(publicPath, pathname, 'index.html');\n\n    if (this.pageIsSSG.get(pagePath)) {\n      // Serve pre-rendered page.\n      return fs.promises.readFile(pagePath, 'utf-8');\n    }\n\n    if (!pagePath.startsWith(normalize(publicPath))) {\n      // Potential path traversal detected.\n      return undefined;\n    }\n\n    if (pagePath === resolve(documentFilePath) || !(await exists(pagePath))) {\n      // View matches with prerender path or file does not exist.\n      this.pageIsSSG.set(pagePath, false);\n\n      return undefined;\n    }\n\n    // Static file exists.\n    const content = await fs.promises.readFile(pagePath, 'utf-8');\n    const isSSG = SSG_MARKER_REGEXP.test(content);\n    this.pageIsSSG.set(pagePath, isSSG);\n\n    return isSSG ? content : undefined;\n  }\n\n  private async renderApplication(opts: CommonEngineRenderOptions): Promise<string> {\n    const moduleOrFactory = this.options?.bootstrap ?? opts.bootstrap;\n    if (!moduleOrFactory) {\n      throw new Error('A module or bootstrap option must be provided.');\n    }\n\n    const extraProviders: StaticProvider[] = [\n      { provide: ɵSERVER_CONTEXT, useValue: 'ssr' },\n      ...(opts.providers ?? []),\n      ...(this.options?.providers ?? []),\n    ];\n\n    let document = opts.document;\n    if (!document && opts.documentFilePath) {\n      document = await this.getDocument(opts.documentFilePath);\n    }\n\n    const commonRenderingOptions = {\n      url: opts.url,\n      document,\n    };\n\n    return isBootstrapFn(moduleOrFactory)\n      ? renderApplication(moduleOrFactory, {\n          platformProviders: extraProviders,\n          ...commonRenderingOptions,\n        })\n      : renderModule(moduleOrFactory, { extraProviders, ...commonRenderingOptions });\n  }\n\n  /** Retrieve the document from the cache or the filesystem */\n  private async getDocument(filePath: string): Promise<string> {\n    let doc = this.templateCache.get(filePath);\n\n    if (!doc) {\n      doc = await fs.promises.readFile(filePath, 'utf-8');\n      this.templateCache.set(filePath, doc);\n    }\n\n    return doc;\n  }\n}\n\nasync function exists(path: fs.PathLike): Promise<boolean> {\n  try {\n    await fs.promises.access(path, fs.constants.F_OK);\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isBootstrapFn(\n  value: unknown,\n): value is (context: BootstrapContext) => Promise<ApplicationRef> {\n  // We can differentiate between a module and a bootstrap function by reading compiler-generated `ɵmod` static property:\n  return typeof value === 'function' && !('ɵmod' in value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type { IncomingHttpHeaders, IncomingMessage } from 'node:http';\nimport type { Http2ServerRequest } from 'node:http2';\n\n/**\n * A set containing all the pseudo-headers defined in the HTTP/2 specification.\n *\n * This set can be used to filter out pseudo-headers from a list of headers,\n * as they are not allowed to be set directly using the `Node.js` Undici API or\n * the web `Headers` API.\n */\nconst HTTP2_PSEUDO_HEADERS = new Set([':method', ':scheme', ':authority', ':path', ':status']);\n\n/**\n * Converts a Node.js `IncomingMessage` or `Http2ServerRequest` into a\n * Web Standard `Request` object.\n *\n * This function adapts the Node.js request objects to a format that can\n * be used by web platform APIs.\n *\n * @param nodeRequest - The Node.js request object (`IncomingMessage` or `Http2ServerRequest`) to convert.\n * @returns A Web Standard `Request` object.\n */\nexport function createWebRequestFromNodeRequest(\n  nodeRequest: IncomingMessage | Http2ServerRequest,\n): Request {\n  const { headers, method = 'GET' } = nodeRequest;\n  const withBody = method !== 'GET' && method !== 'HEAD';\n  const referrer = headers.referer && URL.canParse(headers.referer) ? headers.referer : undefined;\n\n  return new Request(createRequestUrl(nodeRequest), {\n    method,\n    headers: createRequestHeaders(headers),\n    body: withBody ? nodeRequest : undefined,\n    duplex: withBody ? 'half' : undefined,\n    referrer,\n  });\n}\n\n/**\n * Creates a `Headers` object from Node.js `IncomingHttpHeaders`.\n *\n * @param nodeHeaders - The Node.js `IncomingHttpHeaders` object to convert.\n * @returns A `Headers` object containing the converted headers.\n */\nfunction createRequestHeaders(nodeHeaders: IncomingHttpHeaders): Headers {\n  const headers = new Headers();\n\n  for (const [name, value] of Object.entries(nodeHeaders)) {\n    if (HTTP2_PSEUDO_HEADERS.has(name)) {\n      continue;\n    }\n\n    if (typeof value === 'string') {\n      headers.append(name, value);\n    } else if (Array.isArray(value)) {\n      for (const item of value) {\n        headers.append(name, item);\n      }\n    }\n  }\n\n  return headers;\n}\n\n/**\n * Creates a `URL` object from a Node.js `IncomingMessage`, taking into account the protocol, host, and port.\n *\n * @param nodeRequest - The Node.js `IncomingMessage` or `Http2ServerRequest` object to extract URL information from.\n * @returns A `URL` object representing the request URL.\n */\nexport function createRequestUrl(nodeRequest: IncomingMessage | Http2ServerRequest): URL {\n  const {\n    headers,\n    socket,\n    url = '',\n    originalUrl,\n  } = nodeRequest as IncomingMessage & { originalUrl?: string };\n  const protocol =\n    getFirstHeaderValue(headers['x-forwarded-proto']) ??\n    ('encrypted' in socket && socket.encrypted ? 'https' : 'http');\n  const hostname =\n    getFirstHeaderValue(headers['x-forwarded-host']) ?? headers.host ?? headers[':authority'];\n\n  if (Array.isArray(hostname)) {\n    throw new Error('host value cannot be an array.');\n  }\n\n  let hostnameWithPort = hostname;\n  if (!hostname?.includes(':')) {\n    const port = getFirstHeaderValue(headers['x-forwarded-port']);\n    if (port) {\n      hostnameWithPort += `:${port}`;\n    }\n  }\n\n  return new URL(`${protocol}://${hostnameWithPort}${originalUrl ?? url}`);\n}\n\n/**\n * Extracts the first value from a multi-value header string.\n *\n * @param value - A string or an array of strings representing the header values.\n *                           If it's a string, values are expected to be comma-separated.\n * @returns The first trimmed value from the multi-value header, or `undefined` if the input is invalid or empty.\n *\n * @example\n * ```typescript\n * getFirstHeaderValue(\"value1, value2, value3\"); // \"value1\"\n * getFirstHeaderValue([\"value1\", \"value2\"]); // \"value1\"\n * getFirstHeaderValue(undefined); // undefined\n * ```\n */\nfunction getFirstHeaderValue(value: string | string[] | undefined): string | undefined {\n  return value?.toString().split(',', 1)[0]?.trim();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type { ServerResponse } from 'node:http';\nimport type { Http2ServerResponse } from 'node:http2';\n\n/**\n * Streams a web-standard `Response` into a Node.js `ServerResponse`\n * or `Http2ServerResponse`.\n *\n * This function adapts the web `Response` object to write its content\n * to a Node.js response object, handling both HTTP/1.1 and HTTP/2.\n *\n * @param source - The web-standard `Response` object to stream from.\n * @param destination - The Node.js response object (`ServerResponse` or `Http2ServerResponse`) to stream into.\n * @returns A promise that resolves once the streaming operation is complete.\n */\nexport async function writeResponseToNodeResponse(\n  source: Response,\n  destination: ServerResponse | Http2ServerResponse,\n): Promise<void> {\n  const { status, headers, body } = source;\n  destination.statusCode = status;\n\n  let cookieHeaderSet = false;\n  for (const [name, value] of headers.entries()) {\n    if (name === 'set-cookie') {\n      if (cookieHeaderSet) {\n        continue;\n      }\n\n      // Sets the 'set-cookie' header only once to ensure it is correctly applied.\n      // Concatenating 'set-cookie' values can lead to incorrect behavior, so we use a single value from `headers.getSetCookie()`.\n      destination.setHeader(name, headers.getSetCookie());\n      cookieHeaderSet = true;\n    } else {\n      destination.setHeader(name, value);\n    }\n  }\n\n  if ('flushHeaders' in destination) {\n    destination.flushHeaders();\n  }\n\n  if (!body) {\n    destination.end();\n\n    return;\n  }\n\n  try {\n    const reader = body.getReader();\n\n    destination.on('close', () => {\n      reader.cancel().catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error(\n          `An error occurred while writing the response body for: ${destination.req.url}.`,\n          error,\n        );\n      });\n    });\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        destination.end();\n        break;\n      }\n\n      const canContinue = (destination as ServerResponse).write(value);\n      if (canContinue === false) {\n        // Explicitly check for `false`, as AWS may return `undefined` even though this is not valid.\n        // See: https://github.com/CodeGenieApp/serverless-express/issues/683\n        await new Promise<void>((resolve) => destination.once('drain', resolve));\n      }\n    }\n  } catch {\n    destination.end('Internal server error.');\n  }\n}\n"],"names":["gThis","globalThis","process","on","error","console","path","resourceCache","set","resourceContent","outputPath","PERFORMANCE_MARK_PREFIX","step","name","slice","length","maxWordLength","push","duration","toFixed","performance","clearMeasures","log","value","benchmarks","spaces","runMethodAndMeasurePerf","label","asyncMethod","labelName","endLabel","mark","startLabel","SSG_MARKER_REGEXP","CommonEngine","options","templateCache","enablePerformanceProfiler","html","runMethod","renderApplication","opts","inlineCriticalCss","content","publicPath","documentFilePath","dirname","inlineCriticalCssProcessor","retrieveSSGPage","url","undefined","pathname","pagePath","join","pageIsSSG","get","fs","promises","readFile","startsWith","normalize","resolve","exists","headers","createRequestHeaders","body","withBody","nodeRequest","Headers","append","hostnameWithPort","setHeader","getSetCookie","cookieHeaderSet","destination","end","getReader","req","done","reader","read"],"mappings":"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"}